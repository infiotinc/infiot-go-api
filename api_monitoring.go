/*
 * Infiot API
 *
 * # Introduction  <b>Infiot</b> provides API endpoints for interacting with <b> Infiot Management Portal</b>, so that you can rapidly deploy IoT at scale anywhere with automation.  <b>Infiot's</b> Developer-friendly SDKs and APIs enable seamless integration.Leverage <b>Infiot SDK</b> and seamlessly integrate with additional services for early time-to-market.  The <b>Infiot API</b> is a powerful [REST API](https://en.wikipedia.org/wiki/Representational_state_transfer) that can be accessed by an [HTTP](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol) client tools such as curl/wget, or HTTP libraries of most modern programming languages including Python, GoLang, Java.  The API provides abundance of features, listing some of the top rated ones, * Support to interact securely with our API Servers from a Client Web application (<b>API tokens should never be exposed outside</b>).  * The API responds with a well-formatted [JSON](http://www.json.org/) data.  * Support for built-in HTTP features, like HTTP authentication and HTTP verbs, which can be easily interpreted by any HTTP clients that are designed to comply with [HTTP RFC](https://tools.ietf.org/html/rfc2616).   If you have good knowledge with REST API, our reference guide will help serve you to get started.  To start using <b>Infiot</b> APIs, API tokens need to be created  If you have any questions you can reach out to us on [support@infiot.com](mailto:support@infiot.com)  # Endpoints  Our APIs can be accessed through HTTP requests to our API Servers. There are different API servers provisioned based on production stages. The user has to select the applicable API server from the given list of servers populated, and punch in the appropriate MSP tenant name field to get started:  ``` https://{tenant}.api.infiot.net ```  All our APIs are [versioned] (#versioning). If there are any changes to the API which either changes the response format or request parameter, the version would be incremented accordingly.  # Authentication  To authenticate your API request you will need to include your secret token. You can manage your API tokens in the Infiot MSP Portal.The user should have appropriate privileges in the tenant portal for the tokens option to be visible.  Tokens can be generated from `Tokens` navigation window.Your API tokens carry many privileges, so be sure to keep them secure. Do not share your secret API tokens in publicly accessible areas such as GitHub, client-side code, and so on.   All API requests must be made over secure HTTP [HTTPS](https://en.wikipedia.org/wiki/HTTPS). Calls made over plain HTTP or without authentication will fail.  Once the token is generated and ready to use, authorize the API token in the swagger hub, click on the `Authorize` button and in the pop-up, fill the API token and click on `Authorize` again.   # Request Methods  Our API endpoints use [HTTP request methods](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Request_methods) to specify the desired operation to be performed. The documentation below specifies request method supported by each endpoint and the resulting action with its appropriate CRUD workflow.  | Method Type   | CRUD   | Description   | |-  |-  |-  | | GET   | Read   | GET requests can be used to retrieve data (eg: get all tenant details from a Master MSP or MSP)   | | POST   | Create   | POST requests can be used to create a new record (eg: adding new tenants to the Master MSP or MSP)   | | PUT   | Update/Replace   | PUT requests can be used for updating an existing record (eg: updating the name or description of a MSP   | | DELETE   | Delete   | DELETE requests can be used to delete a record (like deleting a MSP from the Master MSP) |   # Response Codes  All API requests will respond with appropriate [HTTP status code](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes). Your API client should handle each response class differently. | Response Code    | Description | |-                 |-            | | 2XX              | These are successful responses and indicate that the API request returned the expected response | | 4XX              | These indicate that there was a problem with the request like a missing parameter or invalid values | |5XX               | These indicate server errors when the server is unreachable or is misconfigured. In this case, you should retry the API request after some delay |   # <a name=\"versioning\"></a>Versioning  All our APIs are versioned. Our current API version is `v1` and we are continuously working on improving it further and provide additional endpoints. If there are any changes to an API which either changes the response format or request parameter, we will increment the version.
 *
 * API version: v9
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */
package netskopebwan

import (
	"context"
	"fmt"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/antihax/optional"
)

// Linger please
var (
	_ context.Context
)

type MonitoringApiService service

/*
MonitoringApiService Get gateway device flows aggregated metrics
Retrieve the aggregated device flows statistics for a gateway ID and timeframe given as parameters. childTenantId that belongs to an Orgnaization tenant is required when the API is accessed using Master MSP/MSP tenant token. The new value/s of the edge should be populated on the Request body. childTenantId can be empty when using an Organization tenant token. &lt;br&gt; &lt;b&gt;Note&lt;/b&gt; the difference in behavior when &#x60;childTenantId&#x60; is passed/not passed when using a MSP/Master MSP token. &lt;br&gt;     | &#x60;childTenantId&#x60; | Behavior                  |    |-----------------|---------------------------|    |  Not passed     | Error Message Code : &#x60;400&#x60;|    |  Passed         | Aggregated device flows statistics are succesfully returned   |
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Identifier
 * @param startDatetime Timestamp indicating the start of the queried time range, in ISO 8601 format. For example &#x27;2019-05-08T05:30:30.206Z&#x27;
 * @param endDatetime Timestamp indicating the end of the queried time range, in ISO 8601 format. For example &#x27;2019-05-08T05:30:30.206Z&#x27;
 * @param ip IP of the device whose flow stats are to be obtained
 * @param optional nil or *MonitoringApiGetGatewayAggregatedDeviceFlowStatsByIDOpts - Optional Parameters:
     * @param "ChildTenantId" (optional.String) -  Tenant Id where the resource exists (Use this parameter if you wish to execute you query to a specific tenant). Make sure the Tenant should be a child of the Tenant where the API token is created
@return GatewayDevicesAggregatedDeviceFlowStats
*/

type MonitoringApiGetGatewayAggregatedDeviceFlowStatsByIDOpts struct {
	ChildTenantId optional.String
}

func (a *MonitoringApiService) GetGatewayAggregatedDeviceFlowStatsByID(ctx context.Context, id string, startDatetime time.Time, endDatetime time.Time, ip string, localVarOptionals *MonitoringApiGetGatewayAggregatedDeviceFlowStatsByIDOpts) (GatewayDevicesAggregatedDeviceFlowStats, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue GatewayDevicesAggregatedDeviceFlowStats
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/monitoring/gateways/{id}/devices/device_flows_totals"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.ChildTenantId.IsSet() {
		localVarQueryParams.Add("childTenantId", parameterToString(localVarOptionals.ChildTenantId.Value(), ""))
	}
	localVarQueryParams.Add("startDatetime", parameterToString(startDatetime, ""))
	localVarQueryParams.Add("endDatetime", parameterToString(endDatetime, ""))
	localVarQueryParams.Add("ip", parameterToString(ip, ""))
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v GatewayDevicesAggregatedDeviceFlowStats
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 0 {
			var v InfiotErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
MonitoringApiService Get gateway devices aggregated metrics
Retrieve the aggregated devices statistics for a gateway ID and timeframe given as parameters. childTenantId that belongs to an Orgnaization tenant is required when the API is accessed using Master MSP/MSP tenant token. The new value/s of the edge should be populated on the Request body. childTenantId can be empty when using an Organization tenant token. &lt;br&gt; &lt;b&gt;Note&lt;/b&gt; the difference in behavior when &#x60;childTenantId&#x60; is passed/not passed when using a MSP/Master MSP token. &lt;br&gt;     | &#x60;childTenantId&#x60; | Behavior                  |    |-----------------|---------------------------|    |  Not passed     | Error Message Code : &#x60;400&#x60;|    |  Passed         | Aggregated devices statistics are succesfully returned   |
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Identifier
 * @param startDatetime Timestamp indicating the start of the queried time range, in ISO 8601 format. For example &#x27;2019-05-08T05:30:30.206Z&#x27;
 * @param endDatetime Timestamp indicating the end of the queried time range, in ISO 8601 format. For example &#x27;2019-05-08T05:30:30.206Z&#x27;
 * @param optional nil or *MonitoringApiGetGatewayAggregatedDeviceStatsByIDOpts - Optional Parameters:
     * @param "ChildTenantId" (optional.String) -  Tenant Id where the resource exists (Use this parameter if you wish to execute you query to a specific tenant). Make sure the Tenant should be a child of the Tenant where the API token is created
@return GatewayDevicesAggregatedDeviceStats
*/

type MonitoringApiGetGatewayAggregatedDeviceStatsByIDOpts struct {
	ChildTenantId optional.String
}

func (a *MonitoringApiService) GetGatewayAggregatedDeviceStatsByID(ctx context.Context, id string, startDatetime time.Time, endDatetime time.Time, localVarOptionals *MonitoringApiGetGatewayAggregatedDeviceStatsByIDOpts) (GatewayDevicesAggregatedDeviceStats, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue GatewayDevicesAggregatedDeviceStats
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/monitoring/gateways/{id}/devices/devices_totals"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.ChildTenantId.IsSet() {
		localVarQueryParams.Add("childTenantId", parameterToString(localVarOptionals.ChildTenantId.Value(), ""))
	}
	localVarQueryParams.Add("startDatetime", parameterToString(startDatetime, ""))
	localVarQueryParams.Add("endDatetime", parameterToString(endDatetime, ""))
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v GatewayDevicesAggregatedDeviceStats
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 0 {
			var v InfiotErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
MonitoringApiService Get gateway paths and links aggregated metrics
Retrieve the aggregated paths and links statistics for a gateway ID and timeframe given as parameters. childTenantId that belongs to an Orgnaization tenant is required when the API is accessed using Master MSP/MSP tenant token. The new value/s of the edge should be populated on the Request body. childTenantId can be empty when using an Organization tenant token. &lt;br&gt; &lt;b&gt;Note&lt;/b&gt; the difference in behavior when &#x60;childTenantId&#x60; is passed/not passed when using a MSP/Master MSP token. &lt;br&gt;     | &#x60;childTenantId&#x60; | Behavior                  |    |-----------------|---------------------------|    |  Not passed     | Error Message Code : &#x60;400&#x60;|    |  Passed         | Aggregated paths and links statistics are succesfully returned   |
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Identifier
 * @param startDatetime Timestamp indicating the start of the queried time range, in ISO 8601 format. For example &#x27;2019-05-08T05:30:30.206Z&#x27;
 * @param endDatetime Timestamp indicating the end of the queried time range, in ISO 8601 format. For example &#x27;2019-05-08T05:30:30.206Z&#x27;
 * @param optional nil or *MonitoringApiGetGatewayAggregatedPathAndLinkStatsByIDOpts - Optional Parameters:
     * @param "ChildTenantId" (optional.String) -  Tenant Id where the resource exists (Use this parameter if you wish to execute you query to a specific tenant). Make sure the Tenant should be a child of the Tenant where the API token is created
@return GatewayWanAggregatedPathsAndLinksStats
*/

type MonitoringApiGetGatewayAggregatedPathAndLinkStatsByIDOpts struct {
	ChildTenantId optional.String
}

func (a *MonitoringApiService) GetGatewayAggregatedPathAndLinkStatsByID(ctx context.Context, id string, startDatetime time.Time, endDatetime time.Time, localVarOptionals *MonitoringApiGetGatewayAggregatedPathAndLinkStatsByIDOpts) (GatewayWanAggregatedPathsAndLinksStats, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue GatewayWanAggregatedPathsAndLinksStats
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/monitoring/gateways/{id}/wan/paths_links_totals"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.ChildTenantId.IsSet() {
		localVarQueryParams.Add("childTenantId", parameterToString(localVarOptionals.ChildTenantId.Value(), ""))
	}
	localVarQueryParams.Add("startDatetime", parameterToString(startDatetime, ""))
	localVarQueryParams.Add("endDatetime", parameterToString(endDatetime, ""))
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v GatewayWanAggregatedPathsAndLinksStats
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 0 {
			var v InfiotErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
MonitoringApiService Get gateway LTE signal time series statistics
Retrieve the LTE signal statistics for a gateway ID and timeframe given as parameters. childTenantId that belongs to an Orgnaization tenant is required when the API is accessed using Master MSP/MSP tenant token. The new value/s of the edge should be populated on the Request body. childTenantId can be empty when using an Organization tenant token. &lt;br&gt; &lt;b&gt;Note&lt;/b&gt; the difference in behavior when &#x60;childTenantId&#x60; is passed/not passed when using a MSP/Master MSP token. &lt;br&gt;     | &#x60;childTenantId&#x60; | Behavior                  |    |-----------------|---------------------------|    |  Not passed     | Error Message Code : &#x60;400&#x60;|    |  Passed         | LTE signal statistics are succesfully returned   |
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Identifier
 * @param startDatetime Timestamp indicating the start of the queried time range, in ISO 8601 format. For example &#x27;2019-05-08T05:30:30.206Z&#x27;
 * @param endDatetime Timestamp indicating the end of the queried time range, in ISO 8601 format. For example &#x27;2019-05-08T05:30:30.206Z&#x27;
 * @param optional nil or *MonitoringApiGetGatewayLTESignalStatsByIDOpts - Optional Parameters:
     * @param "ChildTenantId" (optional.String) -  Tenant Id where the resource exists (Use this parameter if you wish to execute you query to a specific tenant). Make sure the Tenant should be a child of the Tenant where the API token is created
@return GatewaySysLteSignalStats
*/

type MonitoringApiGetGatewayLTESignalStatsByIDOpts struct {
	ChildTenantId optional.String
}

func (a *MonitoringApiService) GetGatewayLTESignalStatsByID(ctx context.Context, id string, startDatetime time.Time, endDatetime time.Time, localVarOptionals *MonitoringApiGetGatewayLTESignalStatsByIDOpts) (GatewaySysLteSignalStats, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue GatewaySysLteSignalStats
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/monitoring/gateways/{id}/system/lte"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.ChildTenantId.IsSet() {
		localVarQueryParams.Add("childTenantId", parameterToString(localVarOptionals.ChildTenantId.Value(), ""))
	}
	localVarQueryParams.Add("startDatetime", parameterToString(startDatetime, ""))
	localVarQueryParams.Add("endDatetime", parameterToString(endDatetime, ""))
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v GatewaySysLteSignalStats
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 0 {
			var v InfiotErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
MonitoringApiService Get gateway interfaces latest metrics
Retrieve the latest interfaces statistics for a gateway ID and timeframe given as parameters. childTenantId that belongs to an Orgnaization tenant is required when the API is accessed using Master MSP/MSP tenant token. The new value/s of the edge should be populated on the Request body. childTenantId can be empty when using an Organization tenant token. &lt;br&gt; &lt;b&gt;Note&lt;/b&gt; the difference in behavior when &#x60;childTenantId&#x60; is passed/not passed when using a MSP/Master MSP token. &lt;br&gt;     | &#x60;childTenantId&#x60; | Behavior                  |    |-----------------|---------------------------|    |  Not passed     | Error Message Code : &#x60;400&#x60;|    |  Passed         | Latest interfaces statistics are succesfully returned   |
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Identifier
 * @param optional nil or *MonitoringApiGetGatewayLatestInterfaceStatsByIDOpts - Optional Parameters:
     * @param "ChildTenantId" (optional.String) -  Tenant Id where the resource exists (Use this parameter if you wish to execute you query to a specific tenant). Make sure the Tenant should be a child of the Tenant where the API token is created
@return GatewayInterfacesLatestStats
*/

type MonitoringApiGetGatewayLatestInterfaceStatsByIDOpts struct {
	ChildTenantId optional.String
}

func (a *MonitoringApiService) GetGatewayLatestInterfaceStatsByID(ctx context.Context, id string, localVarOptionals *MonitoringApiGetGatewayLatestInterfaceStatsByIDOpts) (GatewayInterfacesLatestStats, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue GatewayInterfacesLatestStats
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/monitoring/gateways/{id}/overview/interfaces_latest"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.ChildTenantId.IsSet() {
		localVarQueryParams.Add("childTenantId", parameterToString(localVarOptionals.ChildTenantId.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v GatewayInterfacesLatestStats
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 0 {
			var v InfiotErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
MonitoringApiService Get gateway paths latest metrics
Retrieve the latest paths statistics for a gateway ID and timeframe given as parameters. childTenantId that belongs to an Orgnaization tenant is required when the API is accessed using Master MSP/MSP tenant token. The new value/s of the edge should be populated on the Request body. childTenantId can be empty when using an Organization tenant token. &lt;br&gt; &lt;b&gt;Note&lt;/b&gt; the difference in behavior when &#x60;childTenantId&#x60; is passed/not passed when using a MSP/Master MSP token. &lt;br&gt;     | &#x60;childTenantId&#x60; | Behavior                  |    |-----------------|---------------------------|    |  Not passed     | Error Message Code : &#x60;400&#x60;|    |  Passed         | Latest paths statistics are succesfully returned   |
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Identifier
 * @param optional nil or *MonitoringApiGetGatewayLatestPathStatsByIDOpts - Optional Parameters:
     * @param "ChildTenantId" (optional.String) -  Tenant Id where the resource exists (Use this parameter if you wish to execute you query to a specific tenant). Make sure the Tenant should be a child of the Tenant where the API token is created
@return GatewayPathsLatestStats
*/

type MonitoringApiGetGatewayLatestPathStatsByIDOpts struct {
	ChildTenantId optional.String
}

func (a *MonitoringApiService) GetGatewayLatestPathStatsByID(ctx context.Context, id string, localVarOptionals *MonitoringApiGetGatewayLatestPathStatsByIDOpts) (GatewayPathsLatestStats, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue GatewayPathsLatestStats
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/monitoring/gateways/{id}/overview/paths_latest"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.ChildTenantId.IsSet() {
		localVarQueryParams.Add("childTenantId", parameterToString(localVarOptionals.ChildTenantId.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v GatewayPathsLatestStats
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 0 {
			var v InfiotErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
MonitoringApiService Get gateway routes latest metrics
Retrieve the latest routes statistics for a gateway ID and timeframe given as parameters. childTenantId that belongs to an Orgnaization tenant is required when the API is accessed using Master MSP/MSP tenant token. The new value/s of the edge should be populated on the Request body. childTenantId can be empty when using an Organization tenant token. &lt;br&gt; &lt;b&gt;Note&lt;/b&gt; the difference in behavior when &#x60;childTenantId&#x60; is passed/not passed when using a MSP/Master MSP token. &lt;br&gt;     | &#x60;childTenantId&#x60; | Behavior                  |    |-----------------|---------------------------|    |  Not passed     | Error Message Code : &#x60;400&#x60;|    |  Passed         | Latest routes statistics are succesfully returned   |
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Identifier
 * @param optional nil or *MonitoringApiGetGatewayLatestRouteStatsByIDOpts - Optional Parameters:
     * @param "ChildTenantId" (optional.String) -  Tenant Id where the resource exists (Use this parameter if you wish to execute you query to a specific tenant). Make sure the Tenant should be a child of the Tenant where the API token is created
@return GatewayRoutesLatestStats
*/

type MonitoringApiGetGatewayLatestRouteStatsByIDOpts struct {
	ChildTenantId optional.String
}

func (a *MonitoringApiService) GetGatewayLatestRouteStatsByID(ctx context.Context, id string, localVarOptionals *MonitoringApiGetGatewayLatestRouteStatsByIDOpts) (GatewayRoutesLatestStats, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue GatewayRoutesLatestStats
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/monitoring/gateways/{id}/overview/routes_latest"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.ChildTenantId.IsSet() {
		localVarQueryParams.Add("childTenantId", parameterToString(localVarOptionals.ChildTenantId.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v GatewayRoutesLatestStats
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 0 {
			var v InfiotErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
MonitoringApiService Get gateway system load time series statistics
Retrieve the system load statistics for a gateway ID and timeframe given as parameters. childTenantId that belongs to an Orgnaization tenant is required when the API is accessed using Master MSP/MSP tenant token. The new value/s of the edge should be populated on the Request body. childTenantId can be empty when using an Organization tenant token. &lt;br&gt; &lt;b&gt;Note&lt;/b&gt; the difference in behavior when &#x60;childTenantId&#x60; is passed/not passed when using a MSP/Master MSP token. &lt;br&gt;     | &#x60;childTenantId&#x60; | Behavior                  |    |-----------------|---------------------------|    |  Not passed     | Error Message Code : &#x60;400&#x60;|    |  Passed         | System load statistics are succesfully returned   |
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Identifier
 * @param startDatetime Timestamp indicating the start of the queried time range, in ISO 8601 format. For example &#x27;2019-05-08T05:30:30.206Z&#x27;
 * @param endDatetime Timestamp indicating the end of the queried time range, in ISO 8601 format. For example &#x27;2019-05-08T05:30:30.206Z&#x27;
 * @param optional nil or *MonitoringApiGetGatewayLoadStatsByIDOpts - Optional Parameters:
     * @param "ChildTenantId" (optional.String) -  Tenant Id where the resource exists (Use this parameter if you wish to execute you query to a specific tenant). Make sure the Tenant should be a child of the Tenant where the API token is created
@return GatewaySysLoadStats
*/

type MonitoringApiGetGatewayLoadStatsByIDOpts struct {
	ChildTenantId optional.String
}

func (a *MonitoringApiService) GetGatewayLoadStatsByID(ctx context.Context, id string, startDatetime time.Time, endDatetime time.Time, localVarOptionals *MonitoringApiGetGatewayLoadStatsByIDOpts) (GatewaySysLoadStats, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue GatewaySysLoadStats
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/monitoring/gateways/{id}/system/load"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.ChildTenantId.IsSet() {
		localVarQueryParams.Add("childTenantId", parameterToString(localVarOptionals.ChildTenantId.Value(), ""))
	}
	localVarQueryParams.Add("startDatetime", parameterToString(startDatetime, ""))
	localVarQueryParams.Add("endDatetime", parameterToString(endDatetime, ""))
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v GatewaySysLoadStats
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 0 {
			var v InfiotErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
MonitoringApiService Get gateway memory time series statistics
Retrieve the memory statistics for a gateway ID and timeframe given as parameters. childTenantId that belongs to an Orgnaization tenant is required when the API is accessed using Master MSP/MSP tenant token. The new value/s of the edge should be populated on the Request body. childTenantId can be empty when using an Organization tenant token. &lt;br&gt; &lt;b&gt;Note&lt;/b&gt; the difference in behavior when &#x60;childTenantId&#x60; is passed/not passed when using a MSP/Master MSP token. &lt;br&gt;     | &#x60;childTenantId&#x60; | Behavior                  |    |-----------------|---------------------------|    |  Not passed     | Error Message Code : &#x60;400&#x60;|    |  Passed         | Memory statistics are succesfully returned   |
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Identifier
 * @param startDatetime Timestamp indicating the start of the queried time range, in ISO 8601 format. For example &#x27;2019-05-08T05:30:30.206Z&#x27;
 * @param endDatetime Timestamp indicating the end of the queried time range, in ISO 8601 format. For example &#x27;2019-05-08T05:30:30.206Z&#x27;
 * @param optional nil or *MonitoringApiGetGatewayMemoryStatsByIDOpts - Optional Parameters:
     * @param "ChildTenantId" (optional.String) -  Tenant Id where the resource exists (Use this parameter if you wish to execute you query to a specific tenant). Make sure the Tenant should be a child of the Tenant where the API token is created
@return GatewaySysMemoryStats
*/

type MonitoringApiGetGatewayMemoryStatsByIDOpts struct {
	ChildTenantId optional.String
}

func (a *MonitoringApiService) GetGatewayMemoryStatsByID(ctx context.Context, id string, startDatetime time.Time, endDatetime time.Time, localVarOptionals *MonitoringApiGetGatewayMemoryStatsByIDOpts) (GatewaySysMemoryStats, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue GatewaySysMemoryStats
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/monitoring/gateways/{id}/system/memory"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.ChildTenantId.IsSet() {
		localVarQueryParams.Add("childTenantId", parameterToString(localVarOptionals.ChildTenantId.Value(), ""))
	}
	localVarQueryParams.Add("startDatetime", parameterToString(startDatetime, ""))
	localVarQueryParams.Add("endDatetime", parameterToString(endDatetime, ""))
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v GatewaySysMemoryStats
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 0 {
			var v InfiotErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
MonitoringApiService Get gateway paths and links time series metrics
Retrieve the paths and links statistics for a gateway ID and timeframe given as parameters. childTenantId that belongs to an Orgnaization tenant is required when the API is accessed using Master MSP/MSP tenant token. The new value/s of the edge should be populated on the Request body. childTenantId can be empty when using an Organization tenant token. &lt;br&gt; &lt;b&gt;Note&lt;/b&gt; the difference in behavior when &#x60;childTenantId&#x60; is passed/not passed when using a MSP/Master MSP token. &lt;br&gt;     | &#x60;childTenantId&#x60; | Behavior                  |    |-----------------|---------------------------|    |  Not passed     | Error Message Code : &#x60;400&#x60;|    |  Passed         | paths and links statistics are succesfully returned   |
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Identifier
 * @param startDatetime Timestamp indicating the start of the queried time range, in ISO 8601 format. For example &#x27;2019-05-08T05:30:30.206Z&#x27;
 * @param endDatetime Timestamp indicating the end of the queried time range, in ISO 8601 format. For example &#x27;2019-05-08T05:30:30.206Z&#x27;
 * @param metric String indicating what metric is to be returned by wan statistics
 * @param optional nil or *MonitoringApiGetGatewayPathAndLinkStatsByIDOpts - Optional Parameters:
     * @param "ChildTenantId" (optional.String) -  Tenant Id where the resource exists (Use this parameter if you wish to execute you query to a specific tenant). Make sure the Tenant should be a child of the Tenant where the API token is created
@return GatewayWanPathsAndLinksStats
*/

type MonitoringApiGetGatewayPathAndLinkStatsByIDOpts struct {
	ChildTenantId optional.String
}

func (a *MonitoringApiService) GetGatewayPathAndLinkStatsByID(ctx context.Context, id string, startDatetime time.Time, endDatetime time.Time, metric string, localVarOptionals *MonitoringApiGetGatewayPathAndLinkStatsByIDOpts) (GatewayWanPathsAndLinksStats, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue GatewayWanPathsAndLinksStats
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/monitoring/gateways/{id}/wan/paths_links"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.ChildTenantId.IsSet() {
		localVarQueryParams.Add("childTenantId", parameterToString(localVarOptionals.ChildTenantId.Value(), ""))
	}
	localVarQueryParams.Add("startDatetime", parameterToString(startDatetime, ""))
	localVarQueryParams.Add("endDatetime", parameterToString(endDatetime, ""))
	localVarQueryParams.Add("metric", parameterToString(metric, ""))
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v GatewayWanPathsAndLinksStats
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 0 {
			var v InfiotErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
MonitoringApiService Get gateway uptime time series statistics
Retrieve the uptime statistics for a gateway ID and timeframe given as parameters. childTenantId that belongs to an Orgnaization tenant is required when the API is accessed using Master MSP/MSP tenant token. The new value/s of the edge should be populated on the Request body. childTenantId can be empty when using an Organization tenant token. &lt;br&gt; &lt;b&gt;Note&lt;/b&gt; the difference in behavior when &#x60;childTenantId&#x60; is passed/not passed when using a MSP/Master MSP token. &lt;br&gt;     | &#x60;childTenantId&#x60; | Behavior                  |    |-----------------|---------------------------|    |  Not passed     | Error Message Code : &#x60;400&#x60;|    |  Passed         | Uptime statistics are succesfully returned   |
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Identifier
 * @param startDatetime Timestamp indicating the start of the queried time range, in ISO 8601 format. For example &#x27;2019-05-08T05:30:30.206Z&#x27;
 * @param endDatetime Timestamp indicating the end of the queried time range, in ISO 8601 format. For example &#x27;2019-05-08T05:30:30.206Z&#x27;
 * @param optional nil or *MonitoringApiGetGatewayUptimeStatsByIDOpts - Optional Parameters:
     * @param "ChildTenantId" (optional.String) -  Tenant Id where the resource exists (Use this parameter if you wish to execute you query to a specific tenant). Make sure the Tenant should be a child of the Tenant where the API token is created
@return GatewaySysUptimeStats
*/

type MonitoringApiGetGatewayUptimeStatsByIDOpts struct {
	ChildTenantId optional.String
}

func (a *MonitoringApiService) GetGatewayUptimeStatsByID(ctx context.Context, id string, startDatetime time.Time, endDatetime time.Time, localVarOptionals *MonitoringApiGetGatewayUptimeStatsByIDOpts) (GatewaySysUptimeStats, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue GatewaySysUptimeStats
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/monitoring/gateways/{id}/system/uptime"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.ChildTenantId.IsSet() {
		localVarQueryParams.Add("childTenantId", parameterToString(localVarOptionals.ChildTenantId.Value(), ""))
	}
	localVarQueryParams.Add("startDatetime", parameterToString(startDatetime, ""))
	localVarQueryParams.Add("endDatetime", parameterToString(endDatetime, ""))
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v GatewaySysUptimeStats
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 0 {
			var v InfiotErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
MonitoringApiService Get gateway WiFi strength time series statistics
Retrieve the WiFi strength statistics for a gateway ID and timeframe given as parameters. childTenantId that belongs to an Orgnaization tenant is required when the API is accessed using Master MSP/MSP tenant token. The new value/s of the edge should be populated on the Request body. childTenantId can be empty when using an Organization tenant token. &lt;br&gt; &lt;b&gt;Note&lt;/b&gt; the difference in behavior when &#x60;childTenantId&#x60; is passed/not passed when using a MSP/Master MSP token. &lt;br&gt;     | &#x60;childTenantId&#x60; | Behavior                  |    |-----------------|---------------------------|    |  Not passed     | Error Message Code : &#x60;400&#x60;|    |  Passed         | WiFi strength statistics are succesfully returned   |
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Identifier
 * @param startDatetime Timestamp indicating the start of the queried time range, in ISO 8601 format. For example &#x27;2019-05-08T05:30:30.206Z&#x27;
 * @param endDatetime Timestamp indicating the end of the queried time range, in ISO 8601 format. For example &#x27;2019-05-08T05:30:30.206Z&#x27;
 * @param optional nil or *MonitoringApiGetGatewayWiFiStrengthStatsByIDOpts - Optional Parameters:
     * @param "ChildTenantId" (optional.String) -  Tenant Id where the resource exists (Use this parameter if you wish to execute you query to a specific tenant). Make sure the Tenant should be a child of the Tenant where the API token is created
@return GatewaySysWiFiStrengthStats
*/

type MonitoringApiGetGatewayWiFiStrengthStatsByIDOpts struct {
	ChildTenantId optional.String
}

func (a *MonitoringApiService) GetGatewayWiFiStrengthStatsByID(ctx context.Context, id string, startDatetime time.Time, endDatetime time.Time, localVarOptionals *MonitoringApiGetGatewayWiFiStrengthStatsByIDOpts) (GatewaySysWiFiStrengthStats, *http.Response, error) {
	var (
		localVarHttpMethod  = strings.ToUpper("Get")
		localVarPostBody    interface{}
		localVarFileName    string
		localVarFileBytes   []byte
		localVarReturnValue GatewaySysWiFiStrengthStats
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/monitoring/gateways/{id}/system/wifi"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.ChildTenantId.IsSet() {
		localVarQueryParams.Add("childTenantId", parameterToString(localVarOptionals.ChildTenantId.Value(), ""))
	}
	localVarQueryParams.Add("startDatetime", parameterToString(startDatetime, ""))
	localVarQueryParams.Add("endDatetime", parameterToString(endDatetime, ""))
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
		if err == nil {
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v GatewaySysWiFiStrengthStats
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 0 {
			var v InfiotErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
